<!DOCTYPE html> <!--[if IE 7 ]> <html lang="zh-CN" class="ie7"> <![endif]--> <!--[if IE 8 ]> <html lang="zh-CN" class="ie8"> <![endif]--> <!--[if IE 9 ]> <html lang="zh-CN" class="ie9"> <![endif]--> <!--[if (gte IE 10)|!(IE)]><!--> <html lang="zh-CN"> <!--<![endif]--> <head> <meta charset="UTF-8"> <title>深入理解 iOS 中 GCD 原理 - 维唯为为</title> <meta name="keywords" content="维唯为为,原理"> <meta name="description" content="深入理解 iOS 中 GCD 原理"> <meta name="author" content="luowei"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <meta name="apple-itunes-app" content="app-id=1227288468, app-argument=https://luowei.github.io/%E5%8E%9F%E7%90%86/16074006673494.html"> <!-- Favicon --> <link rel="shortcut icon" href="/favicon.ico"> <!-- Feed --> <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/rss.xml"> <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml"> <!-- Styles --> <link rel="stylesheet" href="https://luowei.github.io/assets/themes/twitter/css/style.css?ver=20151125"> <link rel="stylesheet" href="https://luowei.github.io/assets/themes/twitter/css/font-awesome.min.css?ver=20151122"> <!--[if IE 7 ]><link rel="stylesheet" href="https://luowei.github.io/assets/themes/twitter/css/font-awesome-ie7.min.css?ver=20151122"><![endif]--> <!-- Scripts --> <script type="text/javascript" src="https://luowei.github.io/assets/themes/twitter/js/jquery-1.11.1.min.js"></script> <!--[if lt IE 9]><script src="https://luowei.github.io/assets/themes/twitter/js/html5shiv.min.js"></script><![endif]--> <meta name="baidu-site-verification" content="NajvLOnYvj" /> <meta name="google-site-verification" content="DjKutaNsmRtRRtaKj8OMa1DvyLUMtWr5cB3v_0w75xY" /> <!----> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <script> (adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: "ca-pub-8760692904992206", enable_page_level_ads: true }); </script> <!-- Global site tag (gtag.js) - Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-31488864-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-31488864-2'); </script> </head> <body> <div id="wrap"> <header id="top"> <!-- Home Link --> <a id="logo" href="/" title="回到首页"> <img src="https://luowei.github.io/assets/themes/twitter/img/logo.png" alt="维唯为为"> </a> <!-- Navigation Bar --> <nav id="navbar"> <ul> <li> <a href="/" title="首页">首页</a> </li> <li> <a href="/categories.html" title="分类">分类</a> </li> <li> <a href="/tags.html" title="标签">标签</a> </li> <li> <a href="/messages.html" title="留言板">留言板</a> </li> <li id="about-link" > <a href="/about.html" title="关于我">关于我</a> </li> <li id="rss-link"> <a href="/rss.xml" title="订阅 RSS"><i class="icon-large icon-fixed-width icon-rss"></i></a> </li> </ul> </nav> </header> <section id="main"> <!-- Sidebar --> <aside id="sidebar"> <section id="search-box"> <form id="search-form"> <input id="query" type="text" placeholder="正则搜索"></input> <button type="submit"><i class="icon-search"></i></button> </form> <script type="text/javascript"> $(document).ready(function() { $('#search-form').submit(function() { $('#query').blur().attr('disabled', true); $('#main-content').hide(); $('#loader').show(); $.ajax({url: '/atom.xml?r=' + (Math.random() * 999999), dataType: 'xml', success: function(data) { var rq = new RegExp($('#query').val(), 'im'); var rl = /\/([^\/]+)\.html$/; var html = ''; $(data).find('entry').each(function(index, entry) { var title = $(entry).find('title').text(); var link = $(entry).find('link').attr('href'); var title_en = rl.exec(link)[1].replace('-', ' '); var content = $(entry).find('content').text(); if (rq.test(title) || rq.test(title_en) || rq.test(content)) { var parts = $(entry).find('updated').text().split(/[-T:+]/g); var months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ]; date = parts[2] + ' ' + months[parts[1] - 1] + ' ' + parts[0]; html += '<article class="nested">'; html += '<header><h2><a href="' + link + '">' + title + '</a></h2></header>'; html += '<section><p>' + content + '</p></section>'; html += '<footer><p>更新日期：' + date + '</p></footer>'; html += '</article>'; } }); $('#main-content').html(html); $('#loader').hide(); $('#main-content').show(); }}); $('#query').blur().attr('disabled', false); return false; }); }); </script> </section> <section class="active"> <a href="/" title="查看最近发表"><i class="icon-fixed-width icon-edit"></i> 最近发表</a> <ul> <li><a href="/docker/16769919072309.html" title="查看《Docker容器常用》">Docker容器常用</a></li> <li><a href="/%E5%AD%A6%E4%B9%A0/16766897332728.html" title="查看《区块链学习笔记2》">区块链学习笔记2</a></li> <li><a href="/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/16741455669142.html" title="查看《windows & linux 上设置端口转发》">windows & linux 上设置端口转发</a></li> <li><a href="/%E5%AD%A6%E4%B9%A0/16760467294537.html" title="查看《区块链技术学习笔记1》">区块链技术学习笔记1</a></li> <li><a href="/ios/16610712855071.html" title="查看《iOS Rotation Animation 旋转动画的几种实现》">iOS Rotation Animation 旋转动画的几种实现</a></li> <li><a href="/shell/16610218773192.html" title="查看《使用Socat进行端口转发》">使用Socat进行端口转发</a></li> <li><a href="/shell/16543014008199.html" title="查看《不同的仓库使用不同的github账号提交》">不同的仓库使用不同的github账号提交</a></li> <li><a href="/%E6%AD%A3%E5%88%99/16536646132317.html" title="查看《正则中的Group、反向引用、前向引用》">正则中的Group、反向引用、前向引用</a></li> <li><a href="/regex/16536602052877.html" title="查看《正则删除文本中非匹配项》">正则删除文本中非匹配项</a></li> <li><a href="/%E9%9D%A2%E8%AF%95/16286975952834.html" title="查看《iOS面试常问》">iOS面试常问</a></li> </ul> </section> <section> <a href="/archive.html" title="查看所有存档"><i class="icon-fixed-width icon-file-text"></i> 文章存档</a> <span title="文章总数">152</span> <ul> <li><a href="/archive.html#February-2023">2023 年 02 月 (4)</a></li> <li><a href="/archive.html#August-2022">2022 年 08 月 (2)</a></li> <li><a href="/archive.html#June-2022">2022 年 06 月 (2)</a></li> <li><a href="/archive.html#May-2022">2022 年 05 月 (1)</a></li> <li><a href="/archive.html#November-2021">2021 年 11 月 (1)</a></li> </ul> </section> <section> <a href="/categories.html" title="查看所有分类"><i class="icon-fixed-width icon-folder-open"></i> 文章分类</a> <span title="分类总数">38</span> <ul> <li><a href="/categories.html#linux-ref">linux (12)</a></li> <li><a href="/categories.html#面试-ref">面试 (24)</a></li> <li><a href="/categories.html#author-ref">author (1)</a></li> <li><a href="/categories.html#tutorials-ref">tutorials (5)</a></li> <li><a href="/categories.html#life-ref">life (7)</a></li> <li><a href="/categories.html#LAMP-ref">LAMP (5)</a></li> <li><a href="/categories.html#iOS-ref">iOS (20)</a></li> <li><a href="/categories.html#Tomcat配置-ref">Tomcat配置 (1)</a></li> <li><a href="/categories.html#Regex-ref">Regex (2)</a></li> <li><a href="/categories.html#AI-ref">AI (1)</a></li> <li><a href="/categories.html#数据库-ref">数据库 (1)</a></li> <li><a href="/categories.html#Docker-ref">Docker (1)</a></li> <li><a href="/categories.html#工具-ref">工具 (2)</a></li> <li><a href="/categories.html#课题-ref">课题 (1)</a></li> <li><a href="/categories.html#Audio-ref">Audio (1)</a></li> <li><a href="/categories.html#Jekyll-ref">Jekyll (1)</a></li> <li><a href="/categories.html#SEO-ref">SEO (2)</a></li> <li><a href="/categories.html#FFMPeg-ref">FFMPeg (1)</a></li> <li><a href="/categories.html#色卡-ref">色卡 (1)</a></li> <li><a href="/categories.html#FFmpeg-ref">FFmpeg (1)</a></li> <li><a href="/categories.html#万能输入法-ref">万能输入法 (2)</a></li> <li><a href="/categories.html#其他-ref">其他 (4)</a></li> <li><a href="/categories.html#App-ref">App (2)</a></li> <li><a href="/categories.html#英语-ref">英语 (1)</a></li> <li><a href="/categories.html#sqlite-ref">sqlite (1)</a></li> <li><a href="/categories.html#-ref"> (2)</a></li> <li><a href="/categories.html#shell-ref">shell (4)</a></li> <li><a href="/categories.html#越狱-ref">越狱 (1)</a></li> <li><a href="/categories.html#日历-ref">日历 (2)</a></li> <li><a href="/categories.html#macOS-ref">macOS (2)</a></li> <li><a href="/categories.html#驾考-ref">驾考 (1)</a></li> <li><a href="/categories.html#原理-ref">原理 (26)</a></li> <li><a href="/categories.html#读书-ref">读书 (6)</a></li> <li><a href="/categories.html#直播-ref">直播 (1)</a></li> <li><a href="/categories.html#学习-ref">学习 (4)</a></li> <li><a href="/categories.html#正则-ref">正则 (1)</a></li> <li><a href="/categories.html#网络配置-ref">网络配置 (1)</a></li> <li><a href="/categories.html#docker-ref">docker (1)</a></li> </ul> </section> <section> <a href="/tags.html" title="查看所有标签"><i class="icon-fixed-width icon-tags"></i> 标签云</a> <span title="标签总数">82</span> <div id="tag-cloud"> <a href="/tags.html#linux-ref" style="font-size: 16.5pt; color: #111;">linux</a> <a href="/tags.html#linux命令-ref" style="font-size: 10.5pt; color: #888;">linux命令</a> <a href="/tags.html#linux快捷键-ref" style="font-size: 9pt; color: #999;">linux快捷键</a> <a href="/tags.html#centOS-ref" style="font-size: 9pt; color: #999;">centOS</a> <a href="/tags.html#centOS命令-ref" style="font-size: 9pt; color: #999;">centOS命令</a> <a href="/tags.html#centOS操作命令-ref" style="font-size: 9pt; color: #999;">centOS操作命令</a> <a href="/tags.html#linux信息查看-ref" style="font-size: 9pt; color: #999;">linux信息查看</a> <a href="/tags.html#linux解压与压缩-ref" style="font-size: 9pt; color: #999;">linux解压与压缩</a> <a href="/tags.html#算法问题-ref" style="font-size: 11pt; color: #777;">算法问题</a> <a href="/tags.html#链表-ref" style="font-size: 9pt; color: #999;">链表</a> <a href="/tags.html#作者简介-ref" style="font-size: 9pt; color: #999;">作者简介</a> <a href="/tags.html#Jekyll-ref" style="font-size: 9.5pt; color: #888;">Jekyll</a> <a href="/tags.html#Jekyll安装-ref" style="font-size: 9pt; color: #999;">Jekyll安装</a> <a href="/tags.html#mac安装Jekyll-ref" style="font-size: 9pt; color: #999;">mac安装Jekyll</a> <a href="/tags.html#ssh隧道-ref" style="font-size: 9pt; color: #999;">ssh隧道</a> <a href="/tags.html#内网穿透-ref" style="font-size: 9pt; color: #999;">内网穿透</a> <a href="/tags.html#ssh配VPN-ref" style="font-size: 9pt; color: #999;">ssh配VPN</a> <a href="/tags.html#笔迹-ref" style="font-size: 9pt; color: #999;">笔迹</a> <a href="/tags.html#LAMP-ref" style="font-size: 9.5pt; color: #888;">LAMP</a> <a href="/tags.html#Web-ref" style="font-size: 9pt; color: #999;">Web</a> <a href="/tags.html#防盗链-ref" style="font-size: 9pt; color: #999;">防盗链</a> <a href="/tags.html#多域名绑定-ref" style="font-size: 9pt; color: #999;">多域名绑定</a> <a href="/tags.html#虚拟目录配置-ref" style="font-size: 9pt; color: #999;">虚拟目录配置</a> <a href="/tags.html#教程-ref" style="font-size: 9.5pt; color: #888;">教程</a> <a href="/tags.html#视频教程-ref" style="font-size: 10.5pt; color: #888;">视频教程</a> <a href="/tags.html#负载均衡-ref" style="font-size: 9pt; color: #999;">负载均衡</a> <a href="/tags.html#nginx-ref" style="font-size: 9pt; color: #999;">nginx</a> <a href="/tags.html#iOS示例-ref" style="font-size: 9pt; color: #999;">iOS示例</a> <a href="/tags.html#iOS应用-ref" style="font-size: 9pt; color: #999;">iOS应用</a> <a href="/tags.html#life-ref" style="font-size: 11.5pt; color: #666;">life</a> <a href="/tags.html#ShadowSocks-ref" style="font-size: 9pt; color: #999;">ShadowSocks</a> <a href="/tags.html#shell脚本-ref" style="font-size: 9.5pt; color: #888;">shell脚本</a> <a href="/tags.html#职业规划-ref" style="font-size: 9pt; color: #999;">职业规划</a> <a href="/tags.html#人生-ref" style="font-size: 9pt; color: #999;">人生</a> <a href="/tags.html#web-ref" style="font-size: 9.5pt; color: #888;">web</a> <a href="/tags.html#OAuth2.0-ref" style="font-size: 9pt; color: #999;">OAuth2.0</a> <a href="/tags.html#OAuth原理-ref" style="font-size: 9pt; color: #999;">OAuth原理</a> <a href="/tags.html#iOS-ref" style="font-size: 18pt; color: #000;">iOS</a> <a href="/tags.html#https-ref" style="font-size: 9pt; color: #999;">https</a> <a href="/tags.html#博客-ref" style="font-size: 9pt; color: #999;">博客</a> <a href="/tags.html#开发者经验-ref" style="font-size: 9pt; color: #999;">开发者经验</a> <a href="/tags.html#apache-ref" style="font-size: 10.5pt; color: #888;">apache</a> <a href="/tags.html#服务器-ref" style="font-size: 10.5pt; color: #888;">服务器</a> <a href="/tags.html#tomcat-ref" style="font-size: 9.5pt; color: #888;">tomcat</a> <a href="/tags.html#iOS优化-ref" style="font-size: 9.5pt; color: #888;">iOS优化</a> <a href="/tags.html#iOS内存管理-ref" style="font-size: 9pt; color: #999;">iOS内存管理</a> <a href="/tags.html#webview-ref" style="font-size: 9pt; color: #999;">webview</a> <a href="/tags.html#iOS性能优化-ref" style="font-size: 9pt; color: #999;">iOS性能优化</a> <a href="/tags.html#iOS内存优化-ref" style="font-size: 9pt; color: #999;">iOS内存优化</a> <a href="/tags.html#MVC-ref" style="font-size: 9pt; color: #999;">MVC</a> <a href="/tags.html#MVVM"-ref" style="font-size: 9pt; color: #999;">MVVM"</a> <a href="/tags.html#值类型-ref" style="font-size: 9pt; color: #999;">值类型</a> <a href="/tags.html#UIView-ref" style="font-size: 9pt; color: #999;">UIView</a> <a href="/tags.html#Layout-ref" style="font-size: 9pt; color: #999;">Layout</a> <a href="/tags.html#面试题-ref" style="font-size: 9pt; color: #999;">面试题</a> <a href="/tags.html#原理性问题-ref" style="font-size: 9pt; color: #999;">原理性问题</a> <a href="/tags.html#NSURLConnection-ref" style="font-size: 9pt; color: #999;">NSURLConnection</a> <a href="/tags.html#NSURLSession-ref" style="font-size: 9pt; color: #999;">NSURLSession</a> <a href="/tags.html#server-ref" style="font-size: 9pt; color: #999;">server</a> <a href="/tags.html#C/S通信-ref" style="font-size: 9pt; color: #999;">C/S通信</a> <a href="/tags.html#逆向-ref" style="font-size: 9pt; color: #999;">逆向</a> <a href="/tags.html#Regex-ref" style="font-size: 9pt; color: #999;">Regex</a> <a href="/tags.html#AI-ref" style="font-size: 9pt; color: #999;">AI</a> <a href="/tags.html#sqlite-ref" style="font-size: 9pt; color: #999;">sqlite</a> <a href="/tags.html#mobileconfig-ref" style="font-size: 9pt; color: #999;">mobileconfig</a> <a href="/tags.html#Apache-ref" style="font-size: 9pt; color: #999;">Apache</a> <a href="/tags.html#Docker-ref" style="font-size: 9pt; color: #999;">Docker</a> <a href="/tags.html#Gitlab-ref" style="font-size: 9pt; color: #999;">Gitlab</a> <a href="/tags.html#Wifi-ref" style="font-size: 9pt; color: #999;">Wifi</a> <a href="/tags.html#Mime-ref" style="font-size: 9pt; color: #999;">Mime</a> <a href="/tags.html#UTI-ref" style="font-size: 9.5pt; color: #888;">UTI</a> <a href="/tags.html#感想-ref" style="font-size: 9pt; color: #999;">感想</a> <a href="/tags.html#tools-ref" style="font-size: 9pt; color: #999;">tools</a> <a href="/tags.html#topic-ref" style="font-size: 9pt; color: #999;">topic</a> <a href="/tags.html#sql-ref" style="font-size: 9pt; color: #999;">sql</a> <a href="/tags.html#Audio-ref" style="font-size: 9pt; color: #999;">Audio</a> <a href="/tags.html#Liquid-ref" style="font-size: 9pt; color: #999;">Liquid</a> <a href="/tags.html#seo-ref" style="font-size: 9.5pt; color: #888;">seo</a> <a href="/tags.html#FFMPeg-ref" style="font-size: 9pt; color: #999;">FFMPeg</a> <a href="/tags.html#代理命令-ref" style="font-size: 9pt; color: #999;">代理命令</a> <a href="/tags.html#icns图标-ref" style="font-size: 9pt; color: #999;">icns图标</a> <a href="/tags.html#制作-ref" style="font-size: 9pt; color: #999;">制作</a> </div> </section> <div id="fixed-container"> <section> <a href="#"><i class="icon-fixed-width icon-code"></i> 相关链接</a> <ul> <li><a href="https://wodedata.com" target="_blank">wodedata</a></li> <li><a href="http://app.wodedata.com" target="_blank">作品集</a></li> <li><a href="https://luowei.github.io/list" target="_blank">知不知</a></li> <li><a href="https://tudou.com/home/rootls" target="_blank">土豆视频</a></li> <li><a href="http://my.wodedata.com/wodedata" target="_blank">wodedata听闻站</a></li> </ul> </section> <section> <a href="#"><i class="icon-fixed-width icon-heart"></i> 与我联系</a> <div id="contacts-list"> <a href="mailto:luowei010101@gmail.com" target="_blank" title="Gmail"> <i class="icon-large icon-fixed-width icon-envelope"></i> </a> <a href="https://github.com/luowei" target="_blank" title="GitHub"> <i class="icon-large icon-fixed-width icon-github"></i> </a> <a href="https://weibo.com/rootls" target="_blank" title="新浪微博"> <i class="icon-large icon-fixed-width icon-weibo"></i> </a> <a href="https://v2ex.com/member/luowei010101" target="_blank" title="V2EX"> <i class="icon-large icon-fixed-width icon-v2ex"></i> </a> <a href="https://plus.google.com/113996051315672081772" target="_blank" title="Google+"> <i class="icon-large icon-fixed-width icon-google-plus"></i> </a> <a href="https://twitter.com/luowei010101" target="_blank" title="Twitter"> <i class="icon-large icon-fixed-width icon-twitter"></i> </a> </div> </section> <section> <a href="#"><i class="icon-fixed-width icon-link"></i> 友情链接</a> <ul> <li><a href="https://github.com/Shopify/liquid/wiki/Liquid-for-Designers" target="_blank">Liquid 模板引擎</a></li> <li><a href="https://jekyllrb.com/" target="_blank">Jekyll 静态博客生成器</a></li> </ul> </section> </div> <script type="text/javascript"> $(document).ready(function() { var position = $('#fixed-container').offset(); $(window).scroll(function() { if($(window).scrollTop() > position.top) { $('#fixed-container').css('position','fixed').css('top','0'); } else { $('#fixed-container').css('position','static'); } }); }); </script> </aside> <!-- Main Content --> <div id="main-inner"> <div id="loader"><img src="https://luowei.github.io/assets/themes/twitter/img/loading.gif" alt="请稍侯"></div> <div id="main-content"> <section id="content"> <article class="post"> <header> <h1>深入理解 iOS 中 GCD 原理</h1> <!--<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>--> <!--<script>--> <!--(adsbygoogle = window.adsbygoogle || []).push({--> <!--google_ad_client: "ca-pub-8760692904992206",--> <!--enable_page_level_ads: true--> <!--});--> <!--</script>--> <!--&lt;!&ndash; Global site tag (gtag.js) - Google Analytics &ndash;&gt;--> <!--<script async src="https://www.googletagmanager.com/gtag/js?id=UA-31488864-2"></script>--> <!--<script>--> <!--window.dataLayer = window.dataLayer || [];--> <!--function gtag(){dataLayer.push(arguments);}--> <!--gtag('js', new Date());--> <!--gtag('config', 'UA-31488864-2');--> <!--</script>--> </header> <section> <div class="post-extra"> <div class="pull-left"> <span>08 December 2020</span> </div> <div class="pull-right"> <span id="share"> <a class="wechat" target="_blank" title="分享到微信" href="https://chart.apis.google.com/chart?cht=qr&amp;chs=300x300&amp;chl=https://luowei.github.io/%E5%8E%9F%E7%90%86/16074006673494.html"><i class="icon-large icon-wechat"></i></a> <a class="weibo" target="_blank" title="分享到微博" href="http://service.weibo.com/share/share.php?title=深入理解 iOS 中 GCD 原理 - 维唯为为&amp;url=https://luowei.github.io/%E5%8E%9F%E7%90%86/16074006673494.html&amp;type=3&amp;searchPic=1"><i class="icon-large icon-weibo"></i></a> <a class="qzone" target="_blank" title="分享到 QQ 空间" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://luowei.github.io/%E5%8E%9F%E7%90%86/16074006673494.html&amp;title=深入理解 iOS 中 GCD 原理 - 维唯为为&amp;summary=深入理解 iOS 中 GCD 原理&amp;site=https://luowei.github.io"><i class="icon-large icon-qzone"></i></a> <a class="twitter" target="_blank" title="Share to Twitter" href="https://twitter.com/intent/tweet?url=https://luowei.github.io/%E5%8E%9F%E7%90%86/16074006673494.html&amp;text=深入理解 iOS 中 GCD 原理 - 维唯为为&amp;via=luowei010101"><i class="icon-large icon-twitter"></i></a> <a class="facebook" target="_blank" title="Share to Facebook" href="https://www.facebook.com/sharer.php?u=https://luowei.github.io/%E5%8E%9F%E7%90%86/16074006673494.html&amp;t=深入理解 iOS 中 GCD 原理 - 维唯为为"><i class="icon-large icon-facebook-sign"></i></a> <a class="googleplus" target="_blank" title="Share to Google+" href="https://plus.google.com/share?url=https://luowei.github.io/%E5%8E%9F%E7%90%86/16074006673494.html"><i class="icon-large icon-google-plus-sign"></i></a> </span> </div> </div> <!--<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>--> <!--<ins class="adsbygoogle"--> <!--style="display:block; text-align:center;"--> <!--data-ad-layout="in-article"--> <!--data-ad-format="fluid"--> <!--data-ad-client="ca-pub-8760692904992206"--> <!--data-ad-slot="2948937366"></ins>--> <!--<script>--> <!--(adsbygoogle = window.adsbygoogle || []).push({});--> <!--</script>--> <h1 id="深入理解-ios-中-gcd-原理">深入理解 iOS 中 GCD 原理</h1> <p>首先了解一下，<strong>计算机程序是怎样运行的</strong>，然后再具体讲 GCD 相关内容。</p> <ol> <li>当开始运行程序时，首先应把第一条指令所在存储单元的地址赋予程序计数器PC，然后机器就进入了<em>取指阶段</em>；</li> <li>在取指阶段，CPU从内存中读取的内容必为指令。然后送往数据缓冲寄存器DR，经DR送往指令寄存器IR；</li> <li>之后由指令译码器ID对IR中的指令的操作码字段进行译码，然后又PLA发出执行该指令所需要的各种微操作控制信号，取指阶段到此结束。</li> <li>之后，机器就进入<em>执行指令阶段</em>，这时CPU便执行指令所规定的具体操作。</li> <li>当一条指令执行完毕后，即转入下一条指令的取指阶段，如此循环往复，知道遇到暂停或程序结束为止。</li> </ol> <p><strong>下面看一下GCD主要的API</strong> <img src="https://luowei.github.io/media/16074006673494/16074517435029.jpg" alt="" /></p> <h2 id="串行队列与并行队列"><strong>串行队列与并行队列</strong></h2> <p><strong>在说GCD之前，我们先彻底弄明白串行队列与并行队列的意义和作用。</strong></p> <ul> <li>CPU执行指令是一条条执行的，指令的执行序列是一条按执行时间先后顺序排列的无分叉路径，我们这里管这个叫指令执行流，这个执行流可以是进程或线程，或是某些语言里所说的worker也好；</li> <li>CPU按时间片执行指令，以及多核CPU的出现，可以让1个CPU执行多条不同路径的指令执行流；</li> <li>我们的程序通过编译链接后，最终得到是一个二进制形式的机器码指令的集合；</li> <li>如果CPU的每个时钟脉冲会执行1条指令，那一个3G Hz的CPU在1秒里就可以执行30亿条指令，当然实际上1条计算机指令可能由多个CPU微指令的组合操作构成；</li> <li>队列一般会添加到一个执行流上的，在一个时间段里一个执行流上只能有一个队列在执行；</li> <li>我们<code class="language-plaintext highlighter-rouge">Block</code>代码最终是以结构体对象的形式添加到队列上的；一个队列上可以添加多个<code class="language-plaintext highlighter-rouge">Block</code>代码执行对象；添加在GCD队列上的对象也称之为任务对象；</li> <li>一个串行队列里的所有对象只会分配到同一个执行流上执行，一个并行队列里的对象会分配到多个不同执行流上执行，所以一个串行队列只对应一个执行流，一个并行队列就可能对应多个执行流；</li> <li>所以主队列<code class="language-plaintext highlighter-rouge">dispatch_get_main_queue</code>一定肯定是串行队列，因为它只在主线程运行，而全局队列<code class="language-plaintext highlighter-rouge">dispatch_get_global_queue</code>则是并行队列，这个全局并行队列上的任务具体被分配在哪个执行流上执行，是由系统调试决定，若主线程不忙一般还是分配在主线程上执行；</li> <li><code class="language-plaintext highlighter-rouge">dispatch_async</code>会对作为参数传入的队列里追加一个<code class="language-plaintext highlighter-rouge">Block</code>任务对象,不会阻塞当前队列的执行流,异步执行作为参数传入的队列里的任务；</li> <li><code class="language-plaintext highlighter-rouge">dispatch_sync</code>会对作为参数传入的队列里追加一个<code class="language-plaintext highlighter-rouge">Block</code>任务对象,只会阻塞主队列的执行流,并且会同步执行作为参数传入的队列里的任务；</li> <li><code class="language-plaintext highlighter-rouge">dispatch_barrier_async</code>栅栏函数会等待队列上已有的任务全部完成后，再追加栅栏函数传入的任务到队列，并异步执行此任务；而<code class="language-plaintext highlighter-rouge">dispatch_barrier_sync</code>的差别是同步执行此任务；</li> <li><code class="language-plaintext highlighter-rouge">dispatch_apply</code>在传入的队列里迭代block任务指定次数；</li> <li><code class="language-plaintext highlighter-rouge">dispatch_suspend</code>用于挂起队列或资源；<code class="language-plaintext highlighter-rouge">dispatch_resume</code>用于恢复队列或资源；</li> <li><code class="language-plaintext highlighter-rouge">dispatch_once</code>在程序的生命周期范围内只执行一次；但是并不是简单的只执行一次，<code class="language-plaintext highlighter-rouge">dispatch_once</code>本质上可以接受多次请求，会对此维护一个请求链表，用来保存程序中所有的单例<code class="language-plaintext highlighter-rouge">dispatch_once</code>的静态标记。</li> </ul> <h2 id="队列与dispatch_async的本质"><strong>队列与<code class="language-plaintext highlighter-rouge">dispatch_async</code>的本质</strong></h2> <p><code class="language-plaintext highlighter-rouge">dispatch_async</code> 与 <code class="language-plaintext highlighter-rouge">dispatch_sync</code> 与队列的使用，下面用一段代码来彻底弄明白。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">//代码添加到autoreleasepool中，使用dispatch_get_global_queue系统会优化线程的创建与分配</span>
    <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
        
        <span class="c1">//验证：dispatch_sync不会阻塞全局队列的执行流</span>
        <span class="n">dispatch_queue_t</span> <span class="n">glb_q</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">glb_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="c1">//a添加到全局队列异步执行，</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"a dispatch_sync 调用内部,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>
            <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">glb_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="c1">//b添加到全局队列异步执行，</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"b dispatch_sync 调用内部,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">});</span>
        
        <span class="cm">/* 下面第1个数字表示执行流顺序；m表示主队列,g表示全局队列,后面的数字表示任务在队列中的位置,
         如:m2表示主队列中的第2个任务；t表示线程,t1表示主线程,t2表示其他线程。
         */</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"2_m2_t1. dispatch_async 调用内部,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"1_m1_t1. dispatch_async 调用后,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>
        <span class="p">[</span><span class="n">NSRunLoop</span><span class="p">.</span><span class="n">currentRunLoop</span> <span class="n">runUntilDate</span><span class="o">:</span><span class="p">[</span><span class="n">NSDate</span> <span class="n">dateWithTimeIntervalSinceNow</span><span class="o">:</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">]];</span>

        <span class="n">dispatch_queue_t</span> <span class="n">global_q</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">global_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"3_g1_t1. dispatch_sync 调用内部,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>
            <span class="c1">//因当前主线程已经加了同步锁，所以这里添加任务到主队列只能才采用异步方式添加</span>
            <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span> 
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"6_m4_t1. dispatch_async 调用内部,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>
            <span class="p">});</span>

            <span class="n">dispatch_async</span><span class="p">(</span><span class="n">global_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="c1">//t7添加到全局队列异步执行</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"7_g3_t2. dispatch_sync 调用内部,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">global_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"4_g2_t1. dispatch_sync 调用内部,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">});</span>

        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">global_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
            <span class="c1">//因为t7与t8都在同一个队列上，并且t7早于t8加入队列，所以如果t7与t8分本在同一个线程上的话，t7会早于t8执行；</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"8_g4_t2. dispatch_sync 调用内部,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"5_m3_t1. dispatch_sync 调用后,线程：%@"</span><span class="p">,</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">);</span>

        <span class="p">[</span><span class="n">NSRunLoop</span><span class="p">.</span><span class="n">currentRunLoop</span> <span class="n">runUntilDate</span><span class="o">:</span><span class="p">[</span><span class="n">NSDate</span> <span class="n">dateWithTimeIntervalSinceNow</span><span class="o">:</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">]];</span>
        
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这个代码会输出：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a dispatch_sync 调用内部,线程：&lt;NSThread: 0x100505840&gt;{number = 1, name = main}
b dispatch_sync 调用内部,线程：&lt;NSThread: 0x100505840&gt;{number = 1, name = main}
1_m1_t1. dispatch_async 调用后,线程：&lt;NSThread: 0x100505840&gt;{number = 1, name = main}
2_m2_t1. dispatch_async 调用内部,线程：&lt;NSThread: 0x100505840&gt;{number = 1, name = main}
3_g1_t1. dispatch_sync 调用内部,线程：&lt;NSThread: 0x100505840&gt;{number = 1, name = main}
4_g2_t1. dispatch_sync 调用内部,线程：&lt;NSThread: 0x100505840&gt;{number = 1, name = main}
7_g3_t2. dispatch_sync 调用内部,线程：&lt;NSThread: 0x100520de0&gt;{number = 2, name = (null)}
8_g4_t2. dispatch_sync 调用内部,线程：&lt;NSThread: 0x100520de0&gt;{number = 2, name = (null)}
5_m3_t1. dispatch_sync 调用后,线程：&lt;NSThread: 0x100505840&gt;{number = 1, name = main}
6_m4_t1. dispatch_async 调用内部,线程：&lt;NSThread: 0x100505840&gt;{number = 1, name = main}
</code></pre></div></div> <h2 id="gcd-中主要的api"><strong>GCD 中主要的API</strong></h2> <p><strong>队列</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dispatch_get_main_queue</span><span class="p">()</span> <span class="c1">//取主队列</span>
<span class="n">dispatch_get_global_queue</span><span class="p">()</span> <span class="c1">//取全局队列,第1个参数是线程执行的优先级,第2个参数是预留参数0</span>
<span class="n">dispatch_queue_create</span><span class="p">()</span> <span class="c1">//创建队列,第1个参数标签名,第2个参数NULL表示创建串行队列,DISPATCH_QUEUE_CONCURRENT表示创建并行队列</span>
</code></pre></div></div> <p><strong>执行</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dispatch_async</span><span class="p">()</span> <span class="c1">//异步执行,即在队列里追加一个block对象的任务,不阻塞当前队列的执行流；</span>
<span class="n">dispatch_sync</span><span class="p">()</span> <span class="c1">//同步执行,即在当主队列追加一个block对象的任务,会阻塞主队列的执行流；</span>
<span class="n">dispatch_after</span><span class="p">()</span> <span class="c1">//延后执行</span>
<span class="n">dispatch_once</span><span class="p">()</span>  <span class="c1">//只执行一次</span>
<span class="n">dispatch_apply</span><span class="p">()</span> <span class="c1">//迭代执行指定次数</span>
<span class="n">dispatch_barrier_async</span><span class="p">()</span> <span class="c1">//插入栅栏后异步执行任务</span>
<span class="n">dispatch_barrier_sync</span><span class="p">()</span>  <span class="c1">//插入栅栏后同步执行任务</span>
</code></pre></div></div> <p><strong>调度组</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dispatch_group_create</span><span class="p">()</span>  <span class="c1">//创建调度组</span>
<span class="n">dispatch_group_async</span><span class="p">()</span>   <span class="c1">//向调度组队列里添加任务</span>
<span class="n">dispatch_group_enter</span><span class="p">()</span>   <span class="c1">//每次调用后任务向调度组列队里添加1次,并且计数+1；</span>
<span class="n">dispatch_group_leave</span><span class="p">()</span>   <span class="c1">//每次调用后把在调度组列队里的任务计数计数-1,减到0时从队列里移出任务；</span>
<span class="n">dispatch_group_notify</span><span class="p">()</span>  <span class="c1">//调度组列队中的任务全部执行完后通知block执行</span>
<span class="n">dispatch_group_wait</span><span class="p">()</span>    <span class="c1">//等待整个调度组所有任务执行完</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">dispatch_group_enter</code> 必须与 <code class="language-plaintext highlighter-rouge">dispatch_group_leave</code> 成对出现；</p> <p><strong>信号量</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//dispatch_semaphore_t对象,参数value用于初始化 semaphore.count;</span>
<span class="c1">//semaphore.count小于等于0会阻塞当前线程；</span>
<span class="n">dispatch_semaphore_create</span><span class="p">()</span> 
<span class="n">dispatch_semaphore_wait</span><span class="p">()</span>  <span class="c1">//p操作,对dsema进行原子性的-1,阻塞</span>
<span class="n">dispatch_semaphore_signal</span><span class="p">()</span> <span class="c1">//V操作,对dsema进行原子性+1,唤醒</span>
</code></pre></div></div> <p><strong>调度资源</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dispatch_source_create</span><span class="p">()</span>
<span class="n">dispatch_source_set_timer</span><span class="p">()</span>
<span class="n">dispatch_source_set_event_handler</span><span class="p">()</span>
<span class="n">dispatch_resume</span><span class="p">()</span>
<span class="n">dispatch_suspend</span><span class="p">()</span>
<span class="n">dispatch_source_cancel</span><span class="p">()</span>
<span class="n">dispatch_source_testcancel</span><span class="p">()</span>
<span class="n">dispatch_source_set_cancel_handler</span><span class="p">()</span>
</code></pre></div></div> <h2 id="使用调度组dispatch_group_t"><strong>使用调度组<code class="language-plaintext highlighter-rouge">dispatch_group_t</code></strong></h2> <p><code class="language-plaintext highlighter-rouge">dispatch_group_t</code>可以用来将GCD的任务合并到一个组里来管理，也可以同时监听组里所有任务的执行情况; 在group上任务完成前，<code class="language-plaintext highlighter-rouge">dispatch_group_wait</code>会阻塞当前线程；<code class="language-plaintext highlighter-rouge">dispatch_after</code>延时执行任务；<code class="language-plaintext highlighter-rouge">dispatch_block_wait</code>会阻塞当前线程等待；</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
        <span class="n">dispatch_queue_t</span> <span class="n">main_q</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
        <span class="n">dispatch_queue_t</span> <span class="n">global_q</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>

        <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">global_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"dispatch_async block 1"</span><span class="p">);</span> <span class="p">});</span>
        <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">global_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"dispatch_async block 2"</span><span class="p">);</span> <span class="p">});</span>
        <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">global_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"dispatch_async block 3"</span><span class="p">);</span> <span class="p">});</span>

        <span class="c1">//只有当调用组group中的队列global_q的任务都处理完了，才会通知执行以下的这个block</span>
        <span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">global_q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"Done!"</span><span class="p">);</span> <span class="p">});</span>

        <span class="n">dispatch_group_wait</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="mi">800ull</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">));</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"dispatch_group_wait 后"</span><span class="p">);</span>


        <span class="c1">//使用 dispatch_after 让 block1 在1秒后执行</span>
        <span class="n">dispatch_time_t</span> <span class="n">time</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="mi">1ull</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">);</span>
        <span class="n">dispatch_block_t</span> <span class="n">block1</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"dispatch_after 1秒后 block1"</span><span class="p">);</span> <span class="p">};</span>
        <span class="n">dispatch_after</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">main_q</span><span class="p">,</span> <span class="n">block1</span> <span class="p">);</span>


        <span class="c1">//dispatch_block_wait 用于判断block执行是否超出指定时间</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">"ab.d"</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">dispatch_block_t</span> <span class="n">block2</span> <span class="o">=</span> <span class="n">dispatch_block_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"block2 开始执行"</span><span class="p">);</span>
                <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"block2 结束执行"</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="n">dispatch_async</span><span class="p">(</span><span class="n">global_q</span><span class="p">,</span><span class="n">block2</span><span class="p">);</span>
            <span class="n">dispatch_time_t</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="mi">1ull</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">);</span>
            <span class="c1">//dispatch_block_wait 会阻塞当前线程,并判断block2 在 t2时间内是否已执行完毕；</span>
            <span class="c1">//dispatch_block_wait 只能作用在使用dispatch_block_create创建的block上；</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dispatch_block_wait</span><span class="p">(</span><span class="n">block2</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"block2 执行成功"</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"block2 执行超时"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>

        <span class="p">[</span><span class="n">NSRunLoop</span><span class="p">.</span><span class="n">currentRunLoop</span> <span class="n">runUntilDate</span><span class="o">:</span><span class="p">[</span><span class="n">NSDate</span> <span class="n">dateWithTimeIntervalSinceNow</span><span class="o">:</span><span class="mi">5</span><span class="p">]];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>输出：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dispatch_async</span> <span class="n">block</span> <span class="mi">2</span>
<span class="n">dispatch_async</span> <span class="n">block</span> <span class="mi">1</span>
<span class="n">dispatch_async</span> <span class="n">block</span> <span class="mi">3</span>
<span class="n">Done</span><span class="o">!</span>
<span class="n">dispatch_group_wait</span> <span class="err">后</span>
<span class="n">block2</span> <span class="err">开始执行</span>
<span class="n">block2</span> <span class="err">执行超时</span>
<span class="n">dispatch_after</span> <span class="mi">1</span><span class="err">秒后</span> <span class="n">block1</span>
<span class="n">block2</span> <span class="err">结束执行</span>
</code></pre></div></div> <h2 id="栅栏函数与延迟函数"><strong>栅栏函数与延迟函数</strong></h2> <p>我们知道<code class="language-plaintext highlighter-rouge">dispatch_suspend</code>与<code class="language-plaintext highlighter-rouge">dispatch_resume</code>也可以用来挂起与恢复队列； 下面来看看相关的代码的实现，如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
        <span class="n">dispatch_queue_t</span> <span class="n">q</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">"ab.c"</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>

        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"a reading 1"</span><span class="p">);});</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"a reading 2"</span><span class="p">);});</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"a reading 3"</span><span class="p">);});</span>
        <span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"a writing"</span><span class="p">);});</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"a reading 4"</span><span class="p">);});</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"a reading 5"</span><span class="p">);});</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"a reading 6"</span><span class="p">);});</span>

        <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"b reading 1"</span><span class="p">);});</span>
        <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"b reading 2"</span><span class="p">);});</span>
        <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"b reading 3"</span><span class="p">);});</span>
        <span class="n">dispatch_barrier_sync</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"dispatch_barrier_sync: b writing"</span><span class="p">);});</span>
        <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"b reading 4"</span><span class="p">);});</span>
        <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"b reading 5"</span><span class="p">);});</span>
        <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"b reading 6"</span><span class="p">);});</span>

        <span class="c1">//在q队列里同步迭代block任务5次</span>
        <span class="n">dispatch_apply</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">it</span><span class="p">){</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"dispatch_apply %zu"</span><span class="p">,</span><span class="n">it</span><span class="p">);});</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"Done"</span><span class="p">);</span>

        <span class="c1">//下面模拟飞机起飞</span>
        <span class="n">dispatch_queue_t</span> <span class="n">q1</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">"ab.d"</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"准备"</span><span class="p">);});</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
            <span class="p">[</span><span class="n">NSThread</span> <span class="n">sleepForTimeInterval</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"收起落架"</span><span class="p">);</span>
            <span class="n">dispatch_resume</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="n">dispatch_suspend</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span> <span class="c1">//挂起q1队列,让q1无法添加任务</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"起飞"</span><span class="p">);});</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">predicate</span><span class="p">;</span>
            <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">predicate</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
                <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"dispatch_once %i"</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">}</span>

        <span class="p">[</span><span class="n">NSRunLoop</span><span class="p">.</span><span class="n">currentRunLoop</span> <span class="n">runUntilDate</span><span class="o">:</span><span class="p">[</span><span class="n">NSDate</span> <span class="n">dateWithTimeIntervalSinceNow</span><span class="o">:</span><span class="mi">5</span><span class="p">]];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>输出：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a reading 2
a reading 1
a reading 3
a writing
a reading 4
a reading 5
a reading 6
b reading 1
b reading 2
b reading 3
dispatch_barrier_sync: b writing
b reading 4
b reading 5
b reading 6
dispatch_apply 0
dispatch_apply 1
dispatch_apply 2
dispatch_apply 3
dispatch_apply 4
Done
dispatch_once 0
准备
收起落架
起飞
</code></pre></div></div> <h2 id="信号量dispatch_semaphore_t">信号量<code class="language-plaintext highlighter-rouge">dispatch_semaphore_t</code></h2> <p>用dispatch_semaphore_wait函数进行等待（阻塞，对信号量进行减1），直到上一个任务执行完毕后且通过dispatch_semaphore_signal函数发送信号量（使信号量的值加1），dispatch_semaphore_wait函数收到信号量之后判断信号量的值大于等于1，会再对信号量的值减1。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__block</span> <span class="n">BOOL</span> <span class="n">isSuccess</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
<span class="n">dispatch_semaphore_t</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
    <span class="p">[</span><span class="n">AVCaptureDevice</span> <span class="n">requestAccessForMediaType</span><span class="o">:</span><span class="n">AVMediaTypeVideo</span> <span class="n">completionHandler</span><span class="o">:^</span><span class="p">(</span><span class="n">BOOL</span> <span class="n">granted</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">isSuccess</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
        <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
    <span class="p">}];</span>
<span class="p">});</span>
<span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>
</code></pre></div></div> <h2 id="dispatch-source"><code class="language-plaintext highlighter-rouge">dispatch source</code></h2> <ul> <li><code class="language-plaintext highlighter-rouge">dispatch source</code>作为苹果封装好的一种数据类型，主要方便我们用于处理事件，并且这些处理的事件在操作系统中处理底层，他主要支持以下种类型的事件的处理： <ol> <li>Timer dispatch sources：定时器类型，能够产生周期性的通知事件；</li> <li>Signal dispatch sources：信号类型，当UNIX信号到底时，能够通知应用程序；</li> <li>Descriptor sources：文件描述符类型，处理UNIX的文件或socket描述符，如：数据可读，数据可写，文件被删除、修改或移动，文件的元信息被修改；</li> <li>Process dispatch sources：进程类型，能够通知一些与进程相关的事件类型，如：当进程退出，当进程调用了<code class="language-plaintext highlighter-rouge">fork</code>或<code class="language-plaintext highlighter-rouge">exec</code>，当一个信号传递给了进程；</li> <li>Mach port dispatch sources：端口匹配类型，能够通知一些端口事件的类型；</li> <li>Custom dispatch sources：自定义类型，可以自定义一些事件类型。</li> </ol> </li> <li><code class="language-plaintext highlighter-rouge">Dispatch sources</code>可以替换一些异步的回调函数，特别是用于处理一些与系统相关的事件。使用<code class="language-plaintext highlighter-rouge">dispatch source</code>可以指定希望监控的事件类型，以及<code class="language-plaintext highlighter-rouge">dispatch queue</code>和代码来处理事件，代码的形式可以是block对象或函数。当一个被监听的事件类型的事件到达时，用<code class="language-plaintext highlighter-rouge">Dispatch sources</code>指定的block或函数将会被调用执行；</li> <li>与将任务提交到<code class="language-plaintext highlighter-rouge">GCD dispatch queue</code>不同，<code class="language-plaintext highlighter-rouge">dispatch sources</code>将会持续对所提交的事件进行监控，除非精确取消所感监听的事件；</li> <li>为了防止事件被积压在<code class="language-plaintext highlighter-rouge">dispatch queue</code>中，<code class="language-plaintext highlighter-rouge">dispatch sources</code>实现了一种事件合并机制。如果在上一个事件被放进队列和被执行之前，又来了一个新事件，则<code class="language-plaintext highlighter-rouge">dispatch source</code>将合并老事件和新事件。合并可能会替换或更新事件的信息，这取决于事件的类型，这种机制与UNIX系统信号的不排队机制是一样的。</li> </ul> <h3 id="创建dispatch-sources">创建Dispatch Sources</h3> <p>创建一个<code class="language-plaintext highlighter-rouge">dispatch Sources</code>将涉及两方面的创建过程：创建源事件和<code class="language-plaintext highlighter-rouge">dispatch Sources</code>对象。</p> <p>在创建了源事件之后，则可以按如下的步骤创建<code class="language-plaintext highlighter-rouge">dispatch Sources</code>对象：</p> <ol> <li>使用<code class="language-plaintext highlighter-rouge">dispatch_source_create</code>函数来创建<code class="language-plaintext highlighter-rouge">dispatch Sources</code>对象；</li> <li>配置<code class="language-plaintext highlighter-rouge">dispatch Sources</code>对象： <ol> <li>为<code class="language-plaintext highlighter-rouge">dispatch Sources</code>对象指定一个事件处理句柄；</li> <li>若是<code class="language-plaintext highlighter-rouge">timer sources</code>类型的事件，则可以调用<code class="language-plaintext highlighter-rouge">dispatch_source_set_timer</code>函数来设置timer信息。</li> </ol> </li> <li>配置<code class="language-plaintext highlighter-rouge">dispatch source</code>对象的取消句柄(这个是可选操作)；</li> <li>调用<code class="language-plaintext highlighter-rouge">dispatch_resume</code>函数开始进行事件的处理。</li> </ol> <p>在一个<code class="language-plaintext highlighter-rouge">dispatch sources</code>对象被使用之前，需要对其进行一个附加的配置操作。</p> <ul> <li>当调用<code class="language-plaintext highlighter-rouge">dispatch_source_create</code>函数来创建一个<code class="language-plaintext highlighter-rouge">dispatch sources</code>对象后，该对象仍处于<code class="language-plaintext highlighter-rouge">suspended（挂起）</code>状态；</li> <li>处于挂起状态的<code class="language-plaintext highlighter-rouge">dispatch sources</code>对象是可以接收事件的，但不能处理这些事件，这种机制主要是为了给用户时间来配置事件的处理句柄和执行一些附件的配置操作。</li> </ul> <h3 id="配置event-handler">配置Event Handler</h3> <ul> <li>为了处理<code class="language-plaintext highlighter-rouge">dispatch sources</code>对象所产生的事件，用户必须定义一个<code class="language-plaintext highlighter-rouge">event handler（事件处理句柄）</code>来执行这些事件；</li> <li>事件处理句柄可以是一个<code class="language-plaintext highlighter-rouge">block</code>对象或是一个函数，可以使用<code class="language-plaintext highlighter-rouge">dispatch_source_set_event_handler</code> 和 <code class="language-plaintext highlighter-rouge">dispatch_source_set_event_handler_f</code>函数来配置事件处理句柄；</li> <li>当一个事件到底时，<code class="language-plaintext highlighter-rouge">dispatch source</code>对象会将事件处理句柄投放到<code class="language-plaintext highlighter-rouge">dispatch queue</code>中进行执行；</li> <li>事件处理句柄体的内容负责处理任何到底的事件。如果当一个新事件到达时，而前一个事件处理句柄虽被放入队列，但还未被执行，那么dispatch source将合并两个事件；如果当一个或多个事件到达时，前一个事件的处理句柄已经开始执行，则dispatch source将保存这些事件，直到当前的处理句柄执行后，dispatch source再将事件处理句柄投入队列中；</li> <li><code class="language-plaintext highlighter-rouge">dispatch_source_get_handle</code>返回一个dispatch source监控的数据结构，根据不同的dispatch source类型，则返回的不同语义： <ul> <li>若是描述符类型，则返回一个int类型的文件描述符；</li> <li>若是信号类型，则返回一个int类型的信号数字；</li> <li>若是进程类型，则返回一个pid_t类型的数据结构；</li> <li>若是端口类型，则返回一个端口号；</li> <li>若是其它类型，则返回的值是不确定的； <h3 id="配置cancellation-handler"><strong>配置Cancellation Handler</strong></h3> <p>使用<code class="language-plaintext highlighter-rouge">dispatch_source_set_cancel_handler</code> 或<code class="language-plaintext highlighter-rouge">dispatch_source_set_cancel_handler_f</code>函数进行配置。</p> <h3 id="修改目标queue"><strong>修改目标queue</strong></h3> <p>在创建了<code class="language-plaintext highlighter-rouge">dispatch source</code>对象是会 指定<code class="language-plaintext highlighter-rouge">event</code> 和 <code class="language-plaintext highlighter-rouge">cancellation handlers</code>运行的<code class="language-plaintext highlighter-rouge">queue</code>，之后也可以通过<code class="language-plaintext highlighter-rouge">dispatch_set_target_queue</code>函数修改运行的<code class="language-plaintext highlighter-rouge">queue</code>。</p> </li> </ul> </li> </ul> <h3 id="用-gcd-的-api-封装一个定时器">用 GCD 的 API 封装一个定时器</h3> <p>这里我们先看代码实现：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//创建dispatch source</span>
<span class="n">dispatch_source_t</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">dispatch_source_create</span><span class="p">(</span><span class="n">DISPATCH_SOURCE_TYPE_TIMER</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">timer</span><span class="p">){</span>
    <span class="kt">uint64_t</span> <span class="n">interval</span> <span class="o">=</span> <span class="mi">1ull</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">leeway</span> <span class="o">=</span> <span class="mi">1ull</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span>
     <span class="n">dispatch_source_set_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">dispatch_walltime</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">interval</span><span class="p">,</span><span class="n">leeway</span><span class="p">);</span>
     <span class="n">dispatch_source_set_event_handler</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
         <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">"===== timer"</span><span class="p">);</span>
     <span class="p">});</span>
     <span class="n">dispatch_resume</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
 <span class="p">}</span>

<span class="p">[</span><span class="n">NSRunLoop</span><span class="p">.</span><span class="n">currentRunLoop</span> <span class="n">runUntilDate</span><span class="o">:</span><span class="p">[</span><span class="n">NSDate</span> <span class="n">dateWithTimeIntervalSinceNow</span><span class="o">:</span><span class="mi">5</span><span class="p">]];</span>
</code></pre></div></div> <p><strong>使用dispatch source处理读、写、监听文件事件</strong></p> <ul> <li>创建一个<code class="language-plaintext highlighter-rouge">DISPATCH_SOURCE_TYPE_READ</code>类型的<code class="language-plaintext highlighter-rouge">dispatch source</code>对象，打开一个<code class="language-plaintext highlighter-rouge">file</code>或<code class="language-plaintext highlighter-rouge">socket</code>，从文件或网络中读取数据；</li> <li>创建<code class="language-plaintext highlighter-rouge">DISPATCH_SOURCE_TYPE_WRITE</code>类似的<code class="language-plaintext highlighter-rouge">dispatch source</code>对象，并配置好写文件描述符，一旦创建了<code class="language-plaintext highlighter-rouge">dispatch source</code>对象之后，系统将立即调用<code class="language-plaintext highlighter-rouge">event handler</code>来写入数据到<code class="language-plaintext highlighter-rouge">file</code>或<code class="language-plaintext highlighter-rouge">socket</code>。当完成了写数据，则可以调用<code class="language-plaintext highlighter-rouge">dispatch_source_cancel</code>函数来取消<code class="language-plaintext highlighter-rouge">dispatch source</code>对象；</li> <li>可以创建<code class="language-plaintext highlighter-rouge">DISPATCH_SOURCE_TYPE_VNODE</code>类型的<code class="language-plaintext highlighter-rouge">dispatch source</code>对象，从而当一个文件被删除、写入或重命名等操作时，能够得到通知，实现对文件系统中对象的变化的监控；</li> <li>使用<code class="language-plaintext highlighter-rouge">dispatch source</code>处理读写文件事件，不能把文件描述符配置为阻塞类型的操作；</li> <li>可以使用<code class="language-plaintext highlighter-rouge">dispatch source</code>来异步处理信号，创建一个<code class="language-plaintext highlighter-rouge">DISPATCH_SOURCE_TYPE_SIGNAL</code>类型的<code class="language-plaintext highlighter-rouge">dispatch source</code>对象，当信息到达时可收到通知，但不可以替代<code class="language-plaintext highlighter-rouge">sigaction</code>函数来配置信号处理句柄，也不能不能用于查询所有的signal类型，特别是不能监控<code class="language-plaintext highlighter-rouge">SIGILL</code>、<code class="language-plaintext highlighter-rouge">SIGBUS</code>和<code class="language-plaintext highlighter-rouge">SIGSEGV</code>信号。</li> <li>创建一个<code class="language-plaintext highlighter-rouge">DISPATCH_SOURCE_TYPE_PROC</code>类型的<code class="language-plaintext highlighter-rouge">dispatch source对象可以监控子进程的行为，并进行合适的响应</code>。</li> </ul> <p><a href="https://luowei.github.io/https://gist.github.com/luowei/08de72d67dda439ae52acafe86571cc8">dispatch source 相关应用代码</a></p> <p><strong>取消dispatch source</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">Dispatch source</code>对象将一直保持有效状态，除非手动调用<code class="language-plaintext highlighter-rouge">dispatch_source_cancel</code>函数来取消它。</li> <li>取消了<code class="language-plaintext highlighter-rouge">dispatch source</code>对象后，将不能再接收到新的事件。一般情况下是取消了dispatch source后，立即释放掉该对象。</li> <li>取消dispatch source是一个异步操作，即虽然在调用了dispatch_source_cancel函数之后，dispatch source不能再接收到任何事件，但它还可以继续处理在队列中的事件，直到在队列中的最后一个事件被执行完成后，dispatch source才会执行cancellation handler句柄。</li> </ul> <p><strong>暂停与恢复dispatch source</strong></p> <ul> <li>可以通过使用<code class="language-plaintext highlighter-rouge">dispatch_suspend</code>和 <code class="language-plaintext highlighter-rouge">dispatch_resume</code>函数来暂停和恢复事件传递给<code class="language-plaintext highlighter-rouge">dispatch source</code>对象；</li> <li>当暂停了一个<code class="language-plaintext highlighter-rouge">dispatch source</code>对象之后，所有在这期间传递给<code class="language-plaintext highlighter-rouge">dispatch source</code>对象的事件都会被保存，但当有多个同样事件时，在<code class="language-plaintext highlighter-rouge">dispatch source</code>对象恢复之后，会将这些事件合并为一个再发送给<code class="language-plaintext highlighter-rouge">dispatch source</code>对象，这与UNIX的信号不排队机制是一样的。</li> </ul> <p><a href="https://luowei.github.io/https://gist.github.com/luowei/08de72d67dda439ae52acafe86571cc8">dispatch source使用示例</a></p> <h2 id="参考">参考</h2> <p><a href="https://luowei.github.io/https://www.cnblogs.com/huliangwen/p/5492493.html">iOS 并行编程：GCD Dispatch Sources</a><br /> <a href="https://luowei.github.io/https://juejin.cn/post/6844904143140683789">iOS 中多线程NSOperation NSOperationQueue</a> <br /> <a href="https://luowei.github.io/https://blog.csdn.net/rhddlr/article/details/89503029">GCD定时器使用，封装为单例</a> <br /> <a href="https://luowei.github.io/https://blog.csdn.net/rhddlr/article/details/89488559">ios后台运行</a><br /> <a href="https://luowei.github.io/https://cloud.tencent.com/developer/article/1647232">多线程 GCD底层原理</a> <br /> <a href="https://luowei.github.io/https://juejin.cn/post/6899727732125466631">深入理解iOS中的线程关系和使用方法</a></p> <footer> <p> 本作品由 <a href="mailto:luowei010101@gmail.com">luowei</a> 创作，采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="查看协议详细信息" target="_blank">CC BY-NC-SA 3.0 许可协议</a> 进行许可。 </p> </footer> </section> </article> </section> <section> <div class="tag-box-wrapper"> <ul class="tag-box inline"> <li><i class="icon-large icon-folder-open"></i></li> <li><a href="/categories.html#原理-ref"> 原理 <span>26</span> </a></li> </ul> </div> <div class="pagination"> <ul> <li class="prev"><a href="/%E5%8E%9F%E7%90%86/16071202187230.html" title="Objective-C当中的Block">&larr; 上一篇</a></li> <li><a href="/archive.html">文章列表</a></li> <li class="next"><a href="/%E8%AF%BB%E4%B9%A6/16074064214707.html" title="古代中国梦">下一篇 &rarr;</a></li> </ul> </div> </section> <section id="comments"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <div id="gitalk-container"></div> <script type="text/javascript"> var gitalk = new Gitalk({ clientID: '9d5ee666269c252cf949', clientSecret: '728cd598f1fca9d8c1df1dfa300057883a3a8676', repo: 'luowei.github.io', owner: 'luowei', admin: ['luowei'], id: decodeURI('深入理解 iOS 中 GCD 原理'), distractionFreeMode: false }); gitalk.render('gitalk-container'); </script> </section> </div> </div> <div id="back-top"> <a href="#top" title="回到顶部"> <i class="icon-2x icon-arrow-up"></i> </a> </div> <script type="text/javascript"> $("#back-top").hide(); $(document).ready(function () { $(window).scroll(function () { if ($(this).scrollTop() > 100) { $('#back-top').fadeIn(); } else { $('#back-top').fadeOut(); } }); $('#back-top a').click(function () { $('body,html').animate({ scrollTop: 0 }, 500); return false; }); }); </script> </section> <footer id="bottom"> <p align="center">&copy; 2023 luowei with help from <a href="https://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a> and <a href="https://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a> <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277627361'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277627361%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script> </p> </footer> </div> <script type="text/javascript"> $('article.post a').attr('target', '_blank'); if (navigator.appVersion.indexOf("Mac") != -1) { $('code, pre').css('font-family', 'Courier, monospace'); } </script> <script type="text/javascript"> var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-31488864-2']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> </body> </html>
